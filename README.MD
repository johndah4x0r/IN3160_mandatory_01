# Design Flow #
IN3160 / IN4160 
Version 2026-1
(ripped from the IN3160 assignments repository [in3160/assignmments](https://github.uio.no/in3160/assignments))

## Assignment goal ##
The goal of the first lab exercises is to get practical experience with the tools required to make digital designs. 
It is the first step in order to be able to “_understand important principles for design and testing digital systems_”, 
and to “_be able to perform simulation and synthesis of digital systems_” according to the Learning goals in the 
[course description](https://www.uio.no/studier/emner/matnat/ifi/IN3160/index-eng.html).  

## General information ##
All assignments that require implementation will use the Zedboards available in the lab. 
To implement[^1] designs on the Zedboard, you will use Vivado and Vitis software from AMD/Xilinx. 
To verify[^2] designs, before implementation, we reccomend using GHDL and gtkwave along with the cocotb framework. 
GHDL, gtkwave and cocotb are open source tools. 
Design files shall be written in VHDL. 
Testbenches[^3] shall be written in python. 
To run compilation and start simulation, we run a _Makefile_ script.  

> [!CAUTION]
> Ifi's requirements, and guidelines for mandatory assignments must be followed in all assignments in IN3160/4160.
> 
> [Mandatory assignments ruleset](https://www.uio.no/english/studies/examinations/compulsory-activities/mn-ifi-mandatory.html)
> 
> [Guidelines for mandatory assignments](https://www.uio.no/english/studies/examinations/compulsory-activities/mn-ifi-guidelines.html)
> 
> If you are not already familiar with these, read them now.

### Tool access ###
All tools and hardware are available in the LISP lab, however you may also install most of the tools on your own pc or laptop. 
To aid installation and describe the tool workflow, we have a [cookbook](https://pages.github.uio.no/in3160/cookbook/).
We reccommend following the guide [Installing GHDL, cocotb and GTKWave](https://pages.github.uio.no/in3160/cookbook/Installing/2a-General/)
to install these. 

We expect most students to use Vivado in lab or through the Virtual desktop solution "IFI digital electronics". 
There may be options for installing vivado on personal computers, as noted in chapter one, [Design Flow](https://github.uio.no/in3160/cookbook/wiki/1-Design-Flow) in the cookbook.

[^1]: **Implementing** a design means **realizing the circuit** in or **on physical hardware**. 
  In this course, this means _programming an FPGA_ with the circuit. 
  In other contexts, implementing can also mean creating a digital chip (ASIC) with your circuit design.   
  
[^2]: **Verifying** a digital design is a broad topic, but here we usually mean **testing by simulation**, which is done before _implementation_. 
  The term _testing_, as opposed to _verification_, usually refers to testing on physical hardware, after _implementation_. 

[^3]: **Testbenches** are files that describe how a simulation shall be run. 
  A testbench defines _stimuli_ that is applied to the circuit during simulation. 
  Testbenches normally defines _checkers_, which is routines that check how the circuit responds to _stimuli_ during simulation.
  The testbench also normally reports to what degree our design behaves as predicted throughout the simulation.  

### Files in this exercise ###
In this exercise, we have provided a VHDL design, a testbench and a Makefile. 
Copy these to your own folder.  

| Filename | Description |
| :---: | :---: | 
| first.vhd	| VHDL source file |
| tb_first.py	| Python test bench |
| makefile	| Makefile to build and run the testbench | 

<sup> Attached files. </sup> 

For verification of VHDL, GHDL will be used as compiler and simulator.  
Gtkwave will be used view the waveforms generated by the simulaton. 
To run a simulation you will write a testbench in python that  
To test the design a python testbench built with the cocotb framework will be used.
You will use Vivado to assign which pins on the Zedboard are connected to the ports of out design and more.

## a) ##
* Read first to pages, [Design flow](https://pages.github.uio.no/in3160/cookbook/1-Design-Flow/) and [tools](https://pages.github.uio.no/in3160/cookbook/tools/),
  in the cookbook, and follow the description [GHDL and cocotb](https://pages.github.uio.no/in3160/cookbook/Getting%20started/3a-First-use-of-GHDL-and-cosimulation/).

All necessary files can be obtained from the course website. 
* Simulate the RTL design. (Run make)
* Check the waveform file generated (open the ghw waveform in gtkwave) 
* Implement the design on the Zedboard, following instructions in the [Vivado](https://pages.github.uio.no/in3160/cookbook/Getting%20started/5-Vivado/) chapter.

Before you program the chip, look at the IO report to check that the pin numbers are placed correctly. This means checking the pin assignment stated in the Zedboard Hardware User's Guide:
[Zedboard Hardware User's Guide (2023-12-06)](https://www.avnet.com/wps/wcm/connect/onesite/922900e3-3d57-4cc7-883f-a8b9fbea0cd0/ZedBoard_HW_UG_v2_2.pdf?MOD=AJPERES&CACHEID=ROOTWORKSPACE.Z18_NA5A1I41L0ICD0ABNDMDDG0000-922900e3-3d57-4cc7-883f-a8b9fbea0cd0-nxyWMFS) (Also available from canvas)
* Check the Timing summary report to see whether the timing constraints have been satisfied.

## b) ##
* Change the VHDL code so that the counter becomes an up/down counter by adding an `up` signal. 

The up signal should be assigned to SW6 (pin H17). 
If `up`='1' the counter should count up, and if `up`='0' the counter should count down. 

* In addition, add a `min_count` signal.

This signal shall give a pulse with a duration of 1 clock period when the counter is 0 on the way down. 
`min_count` shall be assigned to pin `LD6`.

* `max_count` shall be modified so that it will give a pulse at the maximum value on the way up. *
* Add the necessary modification to the **XDC file** to Vivado so that the `up` and `min_count` signals are assigned to the correct pin numbers.
* Modify the testbench to verify that the counter is functioning correctly. 

A counting sequence from 0 to 15, and then reversal of the direction and counting down to 0, for example, is fine. 
* Perform the simulation, verify the pin placement and program the chip when everything appears to be correct.

It is sufficient to check that the design behaves as intended by looking at the waveform with gtkwave. 
(Automated testbench with assertions are topic later).

> [!TIP]
> Hint: it is possible to check the value of a signal by using doing:
>	`if dut.portname.value == 0b1010`  # True when the value of portname is binary `1010`.

> [!IMPORTANT]
> **Approval:** 
> Successfully demonstrating your implementation to the lab supervisor
>
> Or
>
> _upload the following to canvas_:
>
> Modified VHDL file, test bench, modified XDC file and IO report.

> [!NOTE]
> The lab supervisor shall make note in canvas when tasks are complete

